



트러블 슈팅

- 제네릭 기능의 목적

제네릭 기능을 처음 배웠을 때는 타입에 유연하게 작동하는 코드를 만들 수 있는 강력한 도구라고 생각했지만 만들면서 여러 제약이 있다는 걸 깨달았습니다.
int형과 double형에 둘 다 대응할 수 있는 calculaor 클래스를 만들면서 있었던 큰 제약은 다음과 같습니다.

1. Parse 메소드 문제: Scanner를 통해 입력된 텍스트를 정수나 실수로 변환할 때 Integer.parseInt() 혹은 Double.parseDouble()을 이용해야 했는데 이 경우는 제네릭 타입 매개변수로 단순하게 만들 수 없었습니다.
2. 산술연산자를 쓸 수 없는 문제: Double형 혹은 Integer형으로 쓰이게 될 제네릭 타입 매개변수 T는 Number를 상속받는 객체로 제약을 만든다 해도 산술연산자를 사용할 수 없었습니다.

이를 위한 생각했던 해결방법은 다음과 같습니다.

1. 메소드에서 instanceOf를 이용해 Double형과 Integer형을 구분하고 조건 분기를 이용해 두 가지 경우의 코드를 작성한다.
2. isDouble이라는 boolean형 전역변수를 만들어서 true/false 값으로 조건 분기를 만든다.
3. Parser라는 함수형 인터페이스를 만들고 Double::parseDouble, Integer::parseInt를 인자로 전달한다. 산술연산자를 쓰는 부분도 따로 메소드 추출해서 작성한 뒤 메소드 참조를 인자로 전달한다.

1번과 2번은 런타임 시에 메인 루프에서 계속 조건을 검사하기 때문에 약간 비효율적일 수 있다고 생각되었고,
3번은 혹시 다른 타입이 추가될 상황에서 확장성도 좋다고 생각했습니다.

그래서 함수형 인터페이스 Parser와 TypeCalculator를 만들었고 main 메소드에서 double/int을 결정하고 계산 루프가 돌아갈 runCalculator 메소드에 인자로 적절한 메소드들을 전달하는 식으로 구현했습니다.



예외 처리

- 0으로 나누기를 하려는 입력이 들어왔을 때 ArithmeticException을 발생시키고, 안내 메시지를 출력한 다음, 이어서 정상적으로 프로그램이 작동할 수 있도록 만들었습니다.

- calculate 메소드는 내부적으로 double형과 int형만 처리할 수 있기 때문에, 지금의 프로젝트에서는 그럴 일이 없지만 유효성 검사 후 제네릭 타입 매개변수가 적절하지 않은 타입일 때 IllegalArgumentException을 발생시켜서 타입 안정성을 가질 수 있도록 만들었습니다.
